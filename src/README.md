
## Менеджер теперь интерфейс

Из темы об абстракции и полиморфизме вы узнали, что при проектировании кода полезно разделять требования к желаемой функциональности объектов и то, как эта функциональность реализована. То есть набор методов, который должен быть у объекта, лучше вынести в интерфейс, а реализацию этих методов – в класс, который его реализует. Теперь нужно применить этот принцип к менеджеру задач.

### Создание интерфейса service.TaskManager

Класс `service.TaskManager` должен стать интерфейсом. В нём нужно собрать список методов, которые должны быть у любого объекта-менеджера. Вспомогательные методы, если вы их создавали, переносить в интерфейс не нужно.

### Переименование существующего класса

Созданный ранее класс менеджера нужно переименовать в `InMemoryTaskManager`. Именно то, что менеджер хранит всю информацию в оперативной памяти, и есть его главное свойство, позволяющее эффективно управлять задачами. Внутри класса должна остаться реализация методов. При этом важно не забыть имплементировать `service.TaskManager`, ведь в Java класс должен явно заявить, что он подходит под требования интерфейса.

### Быстрое создание интерфейса

1. Уберите у всех методов блок реализации.
2. Замените ключевое слово `class` на `interface`.

### Реализация нового класса InMemoryTaskManager

В `InMemoryTaskManager` нужно скопировать бывшее содержимое класса `service.TaskManager`. Чтобы класс реализовывал интерфейс, необходимо после его названия указать ключевое слово `implements` и имя интерфейса — `class InMemoryTaskManager implements service.TaskManager`. Перед реализацией методов интерфейса нужна аннотация `@Override`.

## История просмотров задач

### Добавление метода getHistory()

Добавьте в программу новую функциональность — нужно, чтобы трекер отображал последние просмотренные пользователем задачи. Для этого добавьте метод `getHistory()` в `service.TaskManager` и реализуйте его — он должен возвращать последние 10 просмотренных задач. Просмотром будем считаться вызов у менеджера методов получения задачи по идентификатору — `getTask()`, `getSubtask()` и `getEpic()`. От повторных просмотров избавляться не нужно.

### Формирование истории просмотров

У метода `getHistory()` не будет параметров. Это значит, он формирует свой ответ, анализируя исключительно внутреннее состояние полей объекта менеджера. Подумайте, каким образом и какие данные вы запишете в поля менеджера для возможности извлекать из них историю посещений. Так как в истории отображается, к каким задачам было обращение в методах `getTask()`, `getSubtask()` и `getEpic()`, эти данные в полях менеджера будут обновляться при вызове этих трёх методов.

### Хранение истории просмотров

История просмотров задач — это упорядоченный набор элементов, для хранения которых отлично подойдёт список. При создании менеджера заведите список для хранения просмотренных задач. Этот список должен обновляться в методах `getTask()`, `getSubtask()` и `getEpic()` — просмотренные задачи должны добавляться в конец.

### Ограничение размера списка истории

Размер списка для хранения просмотров не должен превышать десяти элементов. Если размер списка исчерпан, из него нужно удалить самый старый элемент — тот который находится в начале списка.

### Тип списка просмотренных задач

Для списка просмотренных задач нужен тип `model.Task`. Метод `getHistory()` должен возвращать список именно такого типа. В итоге он будет выглядеть так — `List<model.Task> getHistory()`.

## Утилитарный класс Managers

Со временем в приложении трекера появится несколько реализаций интерфейса `service.TaskManager`. Чтобы не зависеть от реализации, создайте утилитарный класс `Managers`. На нём будет лежать вся ответственность за создание менеджера задач. То есть `Managers` должен сам подбирать нужную реализацию `service.TaskManager` и возвращать объект правильного типа.

### Метод getDefault()

У `Managers` будет метод `getDefault()`. При этом вызывающему неизвестен конкретный класс, только то, что объект, который возвращает `getDefault()`, реализует интерфейс `service.TaskManager`.

#### Подсказка про getDefault()

Метод `getDefault()` будет без параметров. Он должен возвращать объект-менеджер, поэтому типом его возвращаемого значения будет `service.TaskManager`.

## Статусы задач как перечисление

### Перенос статусов задач в enum

Ранее мы использовали для хранения статусов задач тип `String` — теперь три соответствующих поля в классе нужно объединить в `enum` с тремя значениями. Не забудьте, что все элементы перечисления принято писать как константы: в верхнем регистре.

## Тестирование вашего решения

Убедитесь, что ваше решение работает! В главном классе воспроизведите несложный пользовательский сценарий:

1. Создайте несколько задач разного типа.
2. Вызовите разные методы интерфейса `service.TaskManager` и напечатайте историю просмотров после каждого вызова. Если код рабочий, то история просмотров задач будет отображаться корректно.

## Интерфейс для управления историей просмотров

Сейчас возможности трекера ограничены — в истории просмотров допускается дублирование и она может содержать только десять задач. В будущем вам нужно будет убрать дубли и расширить её размер. Чтобы подготовиться к этому, проведите рефакторинг кода.

### Создание интерфейса HistoryManager

Создайте отдельный интерфейс для управления историей просмотров — `HistoryManager`. У него будет два метода. Первый `add(model.Task task)` должен помечать задачи как просмотренные, а второй `getHistory()` — возвращать их список.

### Класс InMemoryHistoryManager

Объявите класс `InMemoryHistoryManager` и перенесите в него часть кода для работы с историей из класса `InMemoryTaskManager`. Новый класс `InMemoryHistoryManager` должен реализовывать интерфейс `HistoryManager`.

### Статический метод в классе Managers

Добавьте в служебный класс `Managers` статический метод `HistoryManager getDefaultHistory()`. Он должен возвращать объект `InMemoryHistoryManager` — историю просмотров.

### Обращение к менеджеру истории

Проверьте, что теперь `InMemoryTaskManager` обращается к менеджеру истории через интерфейс `HistoryManager` и использует реализацию, которую возвращает метод `getDefaultHistory()`.

### Повторное тестирование

Ещё раз всё протестируйте!

